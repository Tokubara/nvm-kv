alias out_nvm="rsync_all -m u -f ./engine_race -t nvm-kv"
# alias in="rsync_all -m u -r -f kv -t ../nvm-kv"
alias out="rsync_all -m u -f ../kv"
alias in="rsync_all -m u -r -f kv -t ../kv"

mac:
out
ubuntu/kv下(之后也是如此)
make clean
make
cd test
./single_thread_test
cd ..

结果: 可以过single_thread_test

恢复Makefile, 使得make非dbg的选项, 与dbg的选项不一样. OPT不一样. 但是-I还是保留(也就是说, 还是保留log功能), 只是编译选项不一样, 包括有NDEBUG
mac:
out
ubuntu:
make clean
make
cd test
./single_thread_test # 结果: 卡住了
cd ..
如果恢复编译选项

目的: 怀疑是NDEBUG的问题
修改Makefile, 注释NDEBUG, 也就是不使用NDEBUG选项
mac:
out
ubuntu:
make clean
make
cd test
./single_thread_test # 没有卡住, 顺利执行
cd ..
结论: 的确是NDEBUG的问题

推理: 在kv下, NDEBUG绝对没有任何作用, 除了注释, 它只出现在Makefile中
但有一个外来源可能导致错误, mylib.h
在这个目录下, 搜索NDEBUG, 有2个地方用到了:
#define Assert(cond, ...) (void(0))

以及
#ifdef NDEBUG

#define debug(...) ((void)0)
#define idebug(...) ((void)0)
#define debug_raw(...) ((void)0)
#define idebug_raw(...) ((void)0)

但是不可能是debug函数, 因为我都没用过.
但是Assert看上去无辜极了, 会是Assert?
不敢相信

目的: 仍然保持添加NDEBUG, 对single_thread_test测例添加更多的打印信息, 粗定位, 顺便修改了build.sh, 只生成single_thread_test
mac:
out
ubuntu:
make clean
make
cd test
./single_thread_test # 没有卡住, 顺利执行
cd ..

结果
18:24:56 TRACE /home/parallels/kv/engine_race/engine_race.cc:25: Open /tmp/ramdisk/data/te
st-331516453017026, bucket number: 8
open engine_path: /tmp/ramdisk/data/test-331516453017026
18:24:57 TRACE single_thread_test.cc:48: Write once finish

也就是说, 在执行Read的时候卡住了(key存在的情况下, 之前有一次key并不存在)


