alias out_nvm="rsync_all -m u -f ./engine_race -t nvm-kv"
# alias in="rsync_all -m u -r -f kv -t ../nvm-kv"
alias out="rsync_all -m u -f ../kv"
alias in="rsync_all -m u -r -f kv -t ../kv"

mac:
out
ubuntu/kv下(之后也是如此)
make clean
make
cd test
./single_thread_test
cd ..

结果: 可以过single_thread_test

恢复Makefile, 使得make非dbg的选项, 与dbg的选项不一样. OPT不一样. 但是-I还是保留(也就是说, 还是保留log功能), 只是编译选项不一样, 包括有NDEBUG
mac:
out
ubuntu:
make clean
make
cd test
./single_thread_test # 结果: 卡住了
cd ..
如果恢复编译选项

目的: 怀疑是NDEBUG的问题
修改Makefile, 注释NDEBUG, 也就是不使用NDEBUG选项
mac:
out
ubuntu:
make clean
make
cd test
./single_thread_test # 没有卡住, 顺利执行
cd ..
结论: 的确是NDEBUG的问题

推理: 在kv下, NDEBUG绝对没有任何作用, 除了注释, 它只出现在Makefile中
但有一个外来源可能导致错误, mylib.h
在这个目录下, 搜索NDEBUG, 有2个地方用到了:
#define Assert(cond, ...) (void(0))

以及
#ifdef NDEBUG

#define debug(...) ((void)0)
#define idebug(...) ((void)0)
#define debug_raw(...) ((void)0)
#define idebug_raw(...) ((void)0)

但是不可能是debug函数, 因为我都没用过.
但是Assert看上去无辜极了, 会是Assert?
不敢相信

目的: 仍然保持添加NDEBUG, 对single_thread_test测例添加更多的打印信息, 粗定位, 顺便修改了build.sh, 只生成single_thread_test
mac:
out
ubuntu:
make clean
make
cd test
./single_thread_test # 没有卡住, 顺利执行
cd ..

结果
18:24:56 TRACE /home/parallels/kv/engine_race/engine_race.cc:25: Open /tmp/ramdisk/data/te
st-331516453017026, bucket number: 8
open engine_path: /tmp/ramdisk/data/test-331516453017026
18:24:57 TRACE single_thread_test.cc:48: Write once finish

也就是说, 在执行Read的时候卡住了(key存在的情况下, 之前有一次key并不存在)

目的: 对Read添加更多的打印信息
不过在我编辑的过程中(其实就是发现Read调用了get_string_from_location, 而get_string_from_location调用了Assert). 我意识到了问题. 那就是, Assert是有副作用的, 比如Assert(fstat(key_fd, &st)==0, "%d", key_fd);
再比如Assert(FileAppend...)
因此一个非常重要的原则: 如果你打算置空某个操作(define (void)0), 你得保证这个操作本来就对代码毫无影响. Assert破坏了这个原则. 对于打印调试信息, 不要有副作用. 分离逻辑和打印内容.

修改了Assert, 保证Assert不干实际的事. 不过写法上不好看, 比如, 一个函数内, 有多处Assert, 并且返回类型不一样, rust可以覆盖变量, 但是这里只能起新的变量.
mac:
out
ubuntu:
make clean
make
cd test
./single_thread_test # 没有卡住, 顺利执行
cd ..
鉴于没有问题, 因此去除了single中的log信息

现在需要试试看nvm是不是可以了, 但在此之前, 我们还需要一件事, 那就是重新加上条件编译
mac:
out
ubuntu:
make clean
make
cd test
./single_thread_test # 没有卡住, 顺利执行
cd ..

现在看nvm是不是可以了
mac:
alias out_nvm="rsync_all -m u -f ./engine_race -t nvm-kv"
out_nvm
ubuntu(~/nvm-kv):
make
cd test
bash build.sh
./single_thread_test # 通过
./multi_thread_test # 通过
./crash_test # 通过

查看bench的运行方法
ubuntu(nvm根目录下, 之后也如此):
vim bench/build.sh # std从c++11改为c++17
有一个问题是, bench也需要改一下, 事实上, 本来的bench是没有的, 这是MP添加的, 可以做成表格

首先, 应该用的是build.sh, 而不是build-real-nvm.sh, 后者没有-DMOCK选项
    printf("%d thread, %llu operations per thread, time: %lfus\n", threadNR,
           OP_PER_THREAD, us);
    printf("throughput %lf operations/s\n",
           1ull * (threadNR * OP_PER_THREAD) * 1000000 / us);
问题是, 表格有哪些变量?
Read, Skew, 线程数
我打算修改bench.cc, 输出简单, 不需要正则表达式的提取, 然后用R来制表
但问题是, 我在改谁? 我在改mac的nvm-kv, 但其它部分, 两者应该不一样, 也就是说, 只传bench目录
mac:
rsync_all -m u -f ./bench -t nvm-kv
ubuntu(nvm-kv):
cd bench
bash build.sh
./bench 2 90 0
打印出了大量随机字符串, 就像这样
xLCrFVMSg222X7qObmRNbzFIUVinQAlPWsENSrg7DfOiuEvFFg3Xw9PltNSEvNDifXhJP9XNRI7XY2nuHmJE6Kw3rC
vAI7ks6bmcvCDLHV7JNKN9eCjCAvog3HDPMPBWYyb7m0QqSegmentation fault (core dumped)

